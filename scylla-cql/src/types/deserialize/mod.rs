pub mod frame_slice;

pub use frame_slice::FrameSlice;

use std::error::Error;
use std::fmt::Display;
use std::sync::Arc;

use thiserror::Error;

// Errors

/// An error indicating that a failure happened during type check.
///
/// The error is type-erased so that the crate users can define their own
/// type check impls and their errors.
/// As for the impls defined or generated
/// by the driver itself, the following errors can be returned:
///
/// - [`row::BuiltinTypeCheckError`] is returned when type check of
///   one of types with an impl built into the driver fails. It is also returned
///   from impls generated by the `DeserializeRow` macro.
/// - [`value::BuiltinTypeCheckError`] is analogous to the above but is
///   returned from [`DeserializeValue::type_check`] instead both in the case of
///   builtin impls and impls generated by the `DeserializeValue` macro.
///   It won't be returned by the `Session` directly, but it might be nested
///   in the [`row::BuiltinTypeCheckError`].
#[derive(Debug, Clone, Error)]
#[error(transparent)]
pub struct TypeCheckError(pub(crate) Arc<dyn std::error::Error + Send + Sync>);

impl TypeCheckError {
    /// Constructs a new `TypeCheckError`.
    #[inline]
    pub fn new(err: impl std::error::Error + Send + Sync + 'static) -> Self {
        Self(Arc::new(err))
    }
}

/// An error indicating that a failure happened during deserialization.
///
/// The error is type-erased so that the crate users can define their own
/// deserialization impls and their errors. As for the impls defined or generated
/// by the driver itself, the following errors can be returned:
///
/// - [`row::BuiltinDeserializationError`] is returned when deserialization of
///   one of types with an impl built into the driver fails. It is also returned
///   from impls generated by the `DeserializeRow` macro.
/// - [`value::BuiltinDeserializationError`] is analogous to the above but is
///   returned from [`DeserializeValue::deserialize`] instead both in the case of
///   builtin impls and impls generated by the `DeserializeValue` macro.
///   It won't be returned by the `Session` directly, but it might be nested
///   in the [`row::BuiltinDeserializationError`].
#[derive(Debug, Clone, Error)]
pub struct DeserializationError(Arc<dyn Error + Send + Sync>);

impl DeserializationError {
    /// Constructs a new `DeserializationError`.
    #[inline]
    pub fn new(err: impl Error + Send + Sync + 'static) -> Self {
        Self(Arc::new(err))
    }
}

impl Display for DeserializationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeserializationError: {}", self.0)
    }
}

#[cfg(test)]
mod tests {
    use bytes::{Bytes, BytesMut};

    use crate::frame::response::result::{ColumnSpec, ColumnType, TableSpec};
    use crate::frame::types;

    pub(super) static CELL1: &[u8] = &[1, 2, 3];
    pub(super) static CELL2: &[u8] = &[4, 5, 6, 7];

    pub(super) fn serialize_cells(
        cells: impl IntoIterator<Item = Option<impl AsRef<[u8]>>>,
    ) -> Bytes {
        let mut bytes = BytesMut::new();
        for cell in cells {
            types::write_bytes_opt(cell, &mut bytes).unwrap();
        }
        bytes.freeze()
    }

    pub(super) fn spec(name: &str, typ: ColumnType) -> ColumnSpec {
        ColumnSpec {
            name: name.to_owned(),
            typ,
            table_spec: TableSpec::borrowed("ks", "tbl"),
        }
    }
}
